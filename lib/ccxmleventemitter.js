// Generated by CoffeeScript 1.6.3
/*
v0.9.3beta
Copyright 2013, Andy Spencer < lightbulb a-t laughlinez {dot} com >
*/

/*
    This file is part of ccXmlEventEmitter.

    ccXmlEventEmitter is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Foobar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
    CHANGELOG
    2013-05-30 0.9.0beta - initial upload to github @0.9.0
    2013-06-05 0.9.1beta - added impulse spike behaviour and coping policy @0.9.1
    2013-06-06 0.9.2beta - corrections
    2013-06-08 0.9.3beta - impulse-reading correction, refactored to fully evaluate msg before emitting events - this seperated history tag leakage.
*/

var CurrentCost128XMLBaseStation, EventEmitter, SerialPort, fs, sax, stream,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

SerialPort = require('serialport');

sax = require('sax');

stream = require('stream');

fs = require('fs');

/*
#My EnvIR's native TIME support is very dubious, loosing 2hrs in 400 days (approx 18secs per day)
#so for pseudo-realtime events I have an option to override XML time from base with OS time (useOSTime : true) in options.
#If useOSTime is false, time is as reported by base and is HH:MM:SS string format (i.e its NOT a number) - I therefore classify that as useless and urge you to use useOSTime = true.   
#I *may* look at determining this rubbish time as a rolling 'offset' to place a date part on it shortly - but I seriously think it may be flawed to spend the time.
*/


/*
#TODO: Add some error handling
#TODO: Add test cases
#TODO: General tidy up 
#TODO: Add 'history' event support for those who may want it.
#TODO: Add a runtime manual 'reading' update to allow an external process like a GUI input to rebase the reading's.
#I'll transfer these to an issue tracker shortly.
*/


CurrentCost128XMLBaseStation = (function(_super) {
  __extends(CurrentCost128XMLBaseStation, _super);

  CurrentCost128XMLBaseStation.prototype.serialport = null;

  CurrentCost128XMLBaseStation.prototype.reader = null;

  CurrentCost128XMLBaseStation.prototype.parser = null;

  CurrentCost128XMLBaseStation.prototype.ver = "0.9.3-beta";

  CurrentCost128XMLBaseStation.prototype._s = {
    inMSG: false,
    inREALTIME: false,
    inHIST: false,
    inID: false,
    id: null,
    inSRC: false,
    src: null,
    inDSB: false,
    dsb: null,
    inSENSOR: false,
    sensor: "",
    inTMPR: false,
    temp: 0,
    inCH: false,
    channel: 0,
    inWATTS: false,
    watts: 0,
    inTIME: false,
    time: null,
    inSENSORTYPE: false,
    sensortype: null,
    inIMP: false,
    imp: null,
    inIPU: false,
    ipu: null,
    impStart: {},
    impStartTime: {},
    impLast: {},
    impTime: {},
    impAvg: {},
    readingBAK: {}
  };

  CurrentCost128XMLBaseStation.prototype.emitbase = true;

  function CurrentCost128XMLBaseStation(device, _arg) {
    var self, _ref;
    this.device = device;
    _ref = _arg != null ? _arg : {}, this.useOSTime = _ref.useOSTime, this.emitBaseEvery = _ref.emitBaseEvery, this.spikeThreshold = _ref.spikeThreshold, this.reading = _ref.reading, this.debug = _ref.debug;
    if (this.useOSTime == null) {
      this.useOSTime = false;
    }
    if (this.emitBaseEvery == null) {
      this.emitBaseEvery = 60;
    }
    if (this.spikeThreshold == null) {
      this.spikeThreshold = 0;
    }
    if (this.reading == null) {
      this.reading = {};
    }
    if (this.debug == null) {
      this.debug = false;
    }
    this.logfile = "cc.xml";
    if (this.debug) {
      console.log("debug " + this.debug);
      console.log("useOSTime " + this.useOSTime);
      console.log("emitBaseEvery " + this.emitBaseEvery);
      console.log("reading " + this.reading);
      console.log("spikeThreshold " + this.spikeThreshold);
    }
    self = this;
    this.parser = sax.createStream(false, {
      lowercasetags: true,
      trim: true
    });
    this.parser.onerror = function(e) {
      if (self.debug) {
        console.error("error!", e);
      }
      this.error = null;
      return this.resume();
    };
    this.parser.ontext = function(t) {
      var hms, _s;
      _s = self._s;
      if (_s.inSENSOR) {
        _s.sensor = t;
      }
      if (_s.inID) {
        _s.id = t;
      }
      if (_s.inDSB) {
        _s.dsb = t;
      }
      if (_s.inSRC) {
        _s.src = t;
      }
      if (_s.inTMPR) {
        _s.temp = parseFloat(t);
      }
      if (_s.inTIME) {
        hms = t.split(':');
        _s.time = new Date();
        if (!self.useOSTime) {
          _s.time.setHours(hms[0]);
          _s.time.setMinutes(hms[1]);
          _s.time.setSeconds(hms[2]);
        }
      }
      if (_s.inSENSORTYPE) {
        _s.sensortype = t;
      }
      if (_s.inIMP) {
        _s.imp = parseFloat(t);
      }
      if (_s.inIPU) {
        _s.ipu = parseFloat(t);
      }
      if (_s.inWATTS) {
        return _s.watts = parseFloat(t);
      }
    };
    this.parser.onopentag = function(node) {
      var match, _s;
      _s = self._s;
      if (node.name === 'msg') {
        _s.inMSG = true;
        _s.inREALTIME = true;
      }
      if (_s.inMSG) {
        if (node.name === 'hist') {
          _s.inHIST = true;
          _s.inREALTIME = false;
          if (self.debug) {
            console.log(">>IN HIST");
          }
        }
        if (node.name === 'dsb') {
          _s.inDSB = true;
        }
        if (node.name === 'src') {
          _s.inSRC = true;
        }
        if (node.name === 'id') {
          _s.inID = true;
        }
        if (node.name === 'sensor') {
          _s.inSENSOR = true;
        }
        if (node.name === 'tmpr') {
          _s.inTMPR = true;
        }
        if (node.name === 'time') {
          _s.inTIME = true;
        }
        if (node.name === 'type') {
          _s.inSENSORTYPE = true;
        }
        if (node.name === 'imp') {
          _s.inIMP = true;
        }
        if (node.name === 'ipu') {
          _s.inIPU = true;
        }
        match = /^ch(\d)/.exec(node.name);
        if (match) {
          _s.inCH = true;
          _s.channel = match[1];
        }
        if (_s.inCH) {
          if (node.name === 'watts') {
            return _s.inWATTS = true;
          }
        }
      }
    };
    this.parser.onclosetag = function(tagName) {
      var _s;
      _s = self._s;
      if (tagName === 'msg') {
        if (!_s.inHist) {
          if (self.emitbase) {
            self.emit("base", {
              time: _s.time,
              src: _s.src,
              dsb: _s.dsb,
              temp: _s.temp
            });
            if (self.emitBaseEvery !== 0) {
              self.emitbase = false;
              setTimeout((function() {
                return self.emitbase = true;
              }), 1000 * self.emitBaseEvery);
            }
          }
          if (_s.sensortype === "1") {
            self.emit("sensor", {
              time: _s.time,
              sensor: _s.sensor,
              id: _s.id,
              channel: _s.channel,
              watts: _s.watts
            });
          }
          if (_s.sensortype === "2") {
            self.processImpulse();
          }
        }
        _s.inMSG = false;
        _s.inREALTIME = false;
        _s.inHIST = false;
      }
      if (tagName === 'sensor') {
        _s.inSENSOR = false;
      }
      if (tagName === 'id') {
        _s.inID = false;
      }
      if (tagName === 'dsb') {
        _s.inDSB = false;
      }
      if (tagName === 'tmpr') {
        _s.inTMPR = false;
      }
      if (tagName === 'time') {
        _s.inTIME = false;
      }
      if (tagName === 'src') {
        _s.inSRC = false;
      }
      if (tagName === 'type') {
        _s.inSENSORTYPE = false;
      }
      if (tagName === 'imp') {
        _s.inIMP = false;
      }
      if (tagName === 'ipu') {
        _s.inIPU = false;
      }
      if (tagName === 'hist') {
        if (self.debug) {
          console.log(">>OUT HIST");
        }
      }
      if (tagName === 'watts') {
        _s.inWATTS = false;
      }
      if (tagName.indexOf('ch') === 0) {
        return _s.inCH = false;
      }
    };
    this.parser.onattribute = function(attr) {};
    this.parser.onend = function() {};
    this.reader = new stream.Readable();
    this.reader._read = function(n) {};
    this.reader.pipe(this.parser);
    if (self.debug) {
      console.log("creating:", this.device);
    }
    this.serialPort = new SerialPort.SerialPort(this.device, {
      baudrate: 57600,
      parser: SerialPort.parsers.raw
    });
    this.serialPort.on("open", function() {
      if (self.debug) {
        console.log('open');
      }
      return this.on('data', function(data) {
        self.reader.push(data.toString());
        if (self.logfile != null) {
          return fs.appendFileSync(self.logfile, data.toString());
        }
      });
    });
  }

  CurrentCost128XMLBaseStation.prototype.processImpulse = function() {
    var avg, avgSecs, consumed, curDelta, curNow, doSpike, impPerInterval, oldRead, readinc, self, tot, _base, _name, _s;
    self = this;
    _s = self._s;
    if (_s.inREALTIME) {
      self.emit("impulse", {
        time: _s.time,
        sensor: _s.sensor,
        id: _s.id,
        type: _s.sensortype,
        value: _s.imp,
        ipu: _s.ipu
      });
      curNow = Date.now();
      if (_s.impStart[_s.sensor] == null) {
        if (self.debug) {
          console.log("First time sensor seeding for sensor: " + _s.sensor);
        }
        _s.impStart[_s.sensor] = _s.imp;
        _s.impStartTime[_s.sensor] = curNow;
        _s.impTime[_s.sensor] = curNow;
        _s.impLast[_s.sensor] = 0;
        if ((_base = self.reading)[_name = _s.sensor] == null) {
          _base[_name] = 0;
        }
        _s.readingBAK[_s.sensor] = self.reading[_s.sensor];
        _s.impAvg[_s.sensor] = [];
        if (self.debug) {
          console.log("End First time sensor seeding for sensor: " + _s.sensor);
        }
      } else {
        curDelta = _s.imp - _s.impLast[_s.sensor];
        avgSecs = (curNow - _s.impTime[_s.sensor]) / 1000;
        consumed = _s.imp - _s.impStart[_s.sensor];
        if (self.debug) {
          console.log("consumed: " + consumed + " impulses  since imp-start: " + _s.impStart[_s.sensor] + ", imp-now: " + _s.imp + " pre-reading: " + self.reading[_s.sensor]);
        }
        doSpike = false;
        if ((self.spikeThreshold !== 0) && (curDelta > self.spikeThreshold)) {
          self.emit("impulse-spike", {
            time: _s.time,
            sensor: _s.sensor,
            id: _s.id,
            type: _s.sensortype,
            spike: curDelta
          });
          if (self.debug) {
            console.log("impulse-spike  " + ((new Date()).toLocaleTimeString()) + " prev: " + _s.impLast[_s.sensor] + " curr: " + _s.imp + " delta: " + curDelta + ", tot-consumed: " + consumed);
          }
          if (_s.impAvg[_s.sensor].length >= 1) {
            doSpike = true;
            tot = _s.impAvg[_s.sensor].reduce(function(t, s) {
              return t + s;
            });
            avg = tot / _s.impAvg[_s.sensor].length;
          }
          if (doSpike) {
            _s.impStart[_s.sensor] = _s.imp - avg;
            _s.impLast[_s.sensor] = _s.imp - avg;
            curDelta = avg;
            consumed = avg;
            oldRead = self.reading[_s.sensor];
            self.reading[_s.sensor] = _s.readingBAK[_s.sensor];
            _s.impStartTime[_s.sensor] = curNow;
            if (self.debug) {
              console.log("reading reset to: " + self.reading[_s.sensor] + " from " + oldRead + " using average of: " + avg);
            }
            self.emit("impulse-correction", {
              time: _s.time,
              sensor: _s.sensor,
              id: _s.id,
              type: _s.sensortype,
              oldReading: oldRead,
              newReading: self.reading[_s.sensor],
              newDelta: curDelta
            });
          } else {
            _s.impStart[_s.sensor] = _s.imp;
            _s.impLast[_s.sensor] = _s.imp;
            _s.impTime[_s.sensor] = curNow;
            _s.impStartTime[_s.sensor] = curNow;
            self.reading[_s.sensor] = _s.readingBAK[_s.sensor];
            self.emit("impulse-warning", {
              time: _s.time,
              sensor: _s.sensor,
              id: _s.id,
              type: _s.sensortype,
              newReading: self.reading[_s.sensor]
            });
            if (self.debug) {
              console.log("skipping spiked events - no avg collected");
            }
            return;
          }
        } else {
          _s.readingBAK[_s.sensor] = self.reading[_s.sensor] + (consumed / _s.ipu);
        }
        if (!isFinite(curDelta / _s.ipu)) {
          if (self.debug) {
            console.log("Infinity: " + curDelta + " " + _s.ipu);
          }
          throw new Error("Infinity Assertion");
        }
        readinc = curDelta / _s.ipu;
        if (self.debug) {
          console.log("Incrementing reading by " + readinc);
        }
        self.emit("impulse-reading", {
          time: _s.time,
          sensor: _s.sensor,
          id: _s.id,
          type: _s.sensortype,
          reading: self.reading[_s.sensor] + readinc,
          timeFrom: _s.impStartTime[_s.sensor]
        });
        if (_s.impAvg[_s.sensor].length === 3) {
          _s.impAvg[_s.sensor].pop();
        }
        _s.impAvg[_s.sensor].push(curDelta);
        if (self.debug) {
          tot = _s.impAvg[_s.sensor].reduce(function(t, s) {
            return t + s;
          });
          if (self.debug) {
            console.log("avgArraylen:" + _s.impAvg[_s.sensor].length + " total:" + tot);
          }
        }
        impPerInterval = (curDelta / avgSecs) * 60 * 60;
        self.emit("impulse-delta", {
          time: _s.time,
          sensor: _s.sensor,
          id: _s.id,
          type: _s.sensortype,
          delta: curDelta
        });
        self.emit("impulse-avg", {
          time: _s.time,
          sensor: _s.sensor,
          id: _s.id,
          type: _s.sensortype,
          avg: Math.floor((impPerInterval / _s.ipu) * 1000)
        });
      }
      _s.impLast[_s.sensor] = _s.imp;
      return _s.impTime[_s.sensor] = curNow;
    }
  };

  CurrentCost128XMLBaseStation.prototype.version = function() {
    return this.ver;
  };

  CurrentCost128XMLBaseStation.prototype.close = function() {
    this.serialPort.close();
    this.parser.end();
    this.serialPort = null;
    this.reader = null;
    this.parser = null;
    this.removeAllListeners('sensor').removeAllListeners('impulse').removeAllListeners('impulse-reading').removeAllListeners('impulse-delta').removeAllListeners('impulse-avg');
    if (this.debug) {
      console.log("base --end--");
    }
  };

  return CurrentCost128XMLBaseStation;

})(EventEmitter);

module.exports.CurrentCost128XMLBaseStation = CurrentCost128XMLBaseStation;
