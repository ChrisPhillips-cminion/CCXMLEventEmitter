// Generated by CoffeeScript 1.6.3
/*
v0.9.9beta
Copyright 2013, Andy Spencer < lightbulb a-t laughlinez {dot} com >
*/

/*
    This file is part of ccXmlEventEmitter.

    ccXmlEventEmitter is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Foobar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
    CHANGELOG
    2013-05-30 0.9.0beta - initial upload to github @0.9.0
    2013-06-05 0.9.1beta - added impulse spike behaviour and coping policy @0.9.1
    2013-06-06 0.9.2beta - corrections
    2013-06-08 0.9.3beta - impulse-reading correction, refactored to fully evaluate msg before emitting events - this seperated history tag leakage.
    2013-06-09 0.9.4beta - impulse bug fixes
    2013-06-11 0.9.5beta - bugfixes in impulse and spikes.
    2013-06-12 0.9.6beta - 'averages' events added for cummulative consumption information (impulse counters only) , 
                           events are issued hourly * 24, daily * 7, weekly * 1 and then recycled. 
    2013-06-12 0.9.7beta - better support for cc128 xml 'timestamp' support, now outputs a proper 'date/time' object when useOSTime=false. 
                           An attempt is made to work out the most appropriate 'date' to wrap around the 'time'
                           Can be manually improved by new 'vdate' parameter to seed an actual 'date' to relate to the time. 
    2013-06-13 0.9.8beta - 'file:' moniker added to support 'cc128 xml files' within 'device' parameter, 
                           to allow streaming from source xml files, should use useOSTime=false in these situations 
                           in order to make use of the xml files 'time' system in calculations, as events happen in 'faster than realtime'. 
    2013-06-15 0.9.9beta - 'inpulse-xxxx' events now supply the 'pseudo' channel '1' (should be a non breaking change for people using these events.
                           - 'averaging' events now include normal sensors (within channels). i.e use the 'channel' property to delineate.
                           - 'sensor' events now emit data for 'all' channels, whereas previously only the last channel encountered was used.(technically a bugfix!!)


                           
    TODO:                        
          Add better error handling                 
          Add non-impulse sensor average events
*/

var CurrentCost128XMLBaseStation, EventEmitter, SerialFile, SerialPort, fs, sax, stream,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

SerialPort = require('serialport');

sax = require('sax');

stream = require('stream');

fs = require('fs');

/*
#My EnvIR's native TIME support is very dubious, loosing 2hrs in 400 days (approx 18secs per day)
#so for pseudo-realtime events I have an option to override XML time from base with OS time (useOSTime : true) in options.
#If useOSTime is false, time is as reported by base and is HH:MM:SS string format (i.e its NOT a number) - I therefore classify that as useless and urge you to use useOSTime = true.   
#I *may* look at determining this rubbish time as a rolling 'offset' to place a date part on it shortly - but I seriously think it may be flawed to spend the time.
*/


/*
#TODO: Add some error handling
#TODO: Add test cases
#TODO: General tidy up 
#TODO: Add 'history' event support for those who may want it.
#TODO: Add a runtime manual 'reading' update to allow an external process like a GUI input to rebase the reading's.
#I'll transfer these to an issue tracker shortly.
*/


SerialFile = (function(_super) {
  __extends(SerialFile, _super);

  function SerialFile(filename) {
    var options, self;
    this.filename = filename;
    options = {
      flags: 'r',
      encoding: 'utf-8',
      fd: null,
      mode: 666,
      bufferSize: 64
    };
    stream = fs.createReadStream(this.filename, options);
    self = this;
    stream.on('open', function() {
      return self.emit('open');
    });
    stream.on('data', function(data) {
      return self.emit('data', data);
    });
    stream.on('error', function(e) {
      return self.emit('error', e);
    });
    stream.on('end', function() {
      if (debug) {
        console.log("Stream EOF");
      }
      return self.emit('end');
    });
  }

  SerialFile.prototype.pump = function(data) {
    return this.emit('data', data);
  };

  SerialFile.prototype.close = function() {};

  return SerialFile;

})(EventEmitter);

CurrentCost128XMLBaseStation = (function(_super) {
  __extends(CurrentCost128XMLBaseStation, _super);

  CurrentCost128XMLBaseStation.prototype.serialport = null;

  CurrentCost128XMLBaseStation.prototype.reader = null;

  CurrentCost128XMLBaseStation.prototype.parser = null;

  CurrentCost128XMLBaseStation.prototype.ver = "0.9.9-beta";

  CurrentCost128XMLBaseStation.prototype._s = {
    inMSG: false,
    inREALTIME: false,
    inHIST: false,
    inID: false,
    id: null,
    inSRC: false,
    src: null,
    inDSB: false,
    dsb: null,
    inSENSOR: false,
    sensor: "",
    inTMPR: false,
    temp: 0,
    inCH: false,
    channel: 0,
    inWATTS: false,
    watts: 0,
    inTIME: false,
    time: null,
    inSENSORTYPE: false,
    sensortype: null,
    inIMP: false,
    imp: null,
    inIPU: false,
    ipu: null,
    impStart: {},
    impStartTime: {},
    impLast: {},
    impTime: {},
    impAvg: {},
    readingBAK: {},
    consumedAVG: {},
    currHr: -1,
    cycleHr: -1,
    cycleHrFlag: -1,
    currDy: -1,
    cycleDy: -1,
    cycleDyFlag: -1
  };

  CurrentCost128XMLBaseStation.prototype.emitbase = true;

  CurrentCost128XMLBaseStation.prototype.debugfile = "ccxmleventemitter.log";

  function CurrentCost128XMLBaseStation(device, _arg) {
    var match, self, _ref;
    this.device = device;
    _ref = _arg != null ? _arg : {}, this.useOSTime = _ref.useOSTime, this.emitBaseEvery = _ref.emitBaseEvery, this.spikeThreshold = _ref.spikeThreshold, this.reading = _ref.reading, this.debug = _ref.debug, this.vdate = _ref.vdate, this.logfile = _ref.logfile;
    if (this.useOSTime == null) {
      this.useOSTime = false;
    }
    if (this.emitBaseEvery == null) {
      this.emitBaseEvery = 60;
    }
    if (this.spikeThreshold == null) {
      this.spikeThreshold = 0;
    }
    if (this.reading == null) {
      this.reading = {};
    }
    if (this.debug == null) {
      this.debug = false;
    }
    if (this.vdate == null) {
      this.vdate = null;
    }
    if (this.emitAverages == null) {
      this.emitAverages = true;
    }
    if (this.debug && (this.logfile === void 0)) {
      this.logfile = "cc-" + (((new Date()).getTime() / 1000).toFixed()) + ".xml";
    }
    if (this.debug) {
      console.log("debug " + this.debug);
      console.log("useOSTime " + this.useOSTime);
      console.log("emitBaseEvery " + this.emitBaseEvery);
      console.log("reading " + this.reading);
      console.log("spikeThreshold " + this.spikeThreshold);
      console.log("logfile " + this.logfile);
      console.log("vdate " + this.vdate);
      console.log("emitAverages " + this.emitAverages);
    }
    console.log("logfile " + this.logfile);
    self = this;
    this.parser = sax.createStream(false, {
      lowercasetags: true,
      trim: true
    });
    this.parser.onerror = function(e) {
      if (self.debug) {
        console.error("parser error!", e);
      }
      this.error = null;
      return this.resume();
    };
    this.parser.ontext = function(t) {
      var hms, ms, val, vdiff, _s, _tmp;
      _s = self._s;
      if (_s.inSENSOR) {
        _s.sensor = t;
      }
      if (_s.inID) {
        _s.id = t;
      }
      if (_s.inDSB) {
        _s.dsb = t;
      }
      if (_s.inSRC) {
        _s.src = t;
      }
      if (_s.inTMPR) {
        _s.temp = parseFloat(t);
      }
      if (_s.inTIME) {
        hms = t.split(':');
        if (self.useOSTime) {
          _s.time = new Date();
        } else {
          if (self.vdate === null) {
            _tmp = new Date(0);
            _tmp.setHours(new Date().getHours());
            _tmp.setMinutes(new Date().getMinutes());
            _tmp.setSeconds(new Date().getSeconds());
            self.vdate = new Date(0);
            self.vdate.setHours(hms[0]);
            self.vdate.setMinutes(hms[1]);
            self.vdate.setSeconds(hms[2]);
            vdiff = self.vdate - _tmp;
            if (vdiff > 0) {
              ms = 1 * 24 * 60 * 60 * 1000;
              self.vdate = new Date((new Date()).getTime() - ms);
            } else {
              self.vdate = new Date();
            }
            self.vdate.setHours(hms[0]);
            self.vdate.setMinutes(hms[1]);
            self.vdate.setSeconds(hms[2]);
            _s.time = self.vdate;
          } else {
            if (_s.time === null) {
              _s.time = self.vdate;
            }
            _s.time.setHours(hms[0]);
            _s.time.setMinutes(hms[1]);
            _s.time.setSeconds(hms[2]);
            if (_s.time.getHours() < self.vdate.getHours()) {
              ms = 1 * 24 * 60 * 60 * 1000;
              self.vdate = new Date(self.vdate.getTime() + ms);
              _s.time = new Date(_s.time.getTime() + ms);
            }
          }
        }
        self.vdate = new Date(_s.time);
      }
      if (_s.inSENSORTYPE) {
        _s.sensortype = t;
      }
      if (_s.inIMP) {
        _s.imp = parseFloat(t);
      }
      if (_s.inIPU) {
        val = parseFloat(t);
        if (val > 0) {
          _s.ipu = val;
        }
      }
      if (_s.inWATTS) {
        return _s.watts = parseFloat(t);
      }
    };
    this.parser.onopentag = function(node) {
      var match, _s;
      _s = self._s;
      if (node.name === 'msg') {
        _s.inMSG = true;
        _s.inREALTIME = true;
        _s.channel = '1';
      }
      if (_s.inMSG) {
        if (node.name === 'hist') {
          _s.inHIST = true;
          _s.inREALTIME = false;
          if (self.debug) {
            console.log(">>IN HIST");
          }
        }
        if (node.name === 'dsb') {
          _s.inDSB = true;
        }
        if (node.name === 'src') {
          _s.inSRC = true;
        }
        if (node.name === 'id') {
          _s.inID = true;
        }
        if (node.name === 'sensor') {
          _s.inSENSOR = true;
        }
        if (node.name === 'tmpr') {
          _s.inTMPR = true;
        }
        if (node.name === 'time') {
          _s.inTIME = true;
        }
        if (node.name === 'type') {
          _s.inSENSORTYPE = true;
        }
        if (node.name === 'imp') {
          _s.inIMP = true;
        }
        if (node.name === 'ipu') {
          _s.inIPU = true;
        }
        match = /^ch(\d)/.exec(node.name);
        if (match) {
          _s.inCH = true;
          _s.channel = match[1];
        }
        if (_s.inCH) {
          if (node.name === 'watts') {
            return _s.inWATTS = true;
          }
        }
      }
    };
    this.parser.onclosetag = function(tagName) {
      var avgdb, channel, ck, counter, currHr, cv, darr, dtot, harr, havg, hrly, htot, k, sensor, skippedhrs, v, warr, wtot, _i, _len, _ref1, _ref2, _ref3, _s;
      _s = self._s;
      if (tagName === 'time') {
        if (self.emitAverages) {
          if (_s.currHr === -1) {
            _s.currHr = _s.time.getHours();
            _s.cycleHr = _s.currHr;
            _s.currDy = _s.time.getDay();
            _s.cycleDy = _s.currDy;
          }
        }
        _s.inTIME = false;
      }
      if (tagName.indexOf('ch') === 0) {
        if (!_s.inHist) {
          if (_s.sensortype === "1") {
            self.emit("sensor", {
              time: _s.time,
              sensor: _s.sensor,
              id: _s.id,
              channel: _s.channel,
              watts: _s.watts
            });
            if (self.emitAverages) {
              avgdb = self.getAVGDb(_s.sensor, _s.channel);
              hrly = avgdb["hourly"][_s.time.getHours().toString()]["data"];
              hrly.push(_s.watts);
              self.putAVGDb(_s.sensor, _s.channel, avgdb);
            }
          }
        }
        _s.inCH = false;
      }
      if (tagName === 'msg') {
        if (!_s.inHIST) {
          if (self.emitbase) {
            self.emit("base", {
              time: _s.time,
              src: _s.src,
              dsb: _s.dsb,
              temp: _s.temp
            });
            if (self.emitBaseEvery !== 0) {
              self.emitbase = false;
              setTimeout((function() {
                return self.emitbase = true;
              }), 1000 * self.emitBaseEvery);
            }
          }
          if (_s.sensortype === "2") {
            self.processImpulse();
          }
          if (self.emitAverages) {
            if (_s.currHr !== _s.time.getHours()) {
              skippedhrs = [];
              counter = _s.currHr;
              while (counter !== _s.time.getHours()) {
                skippedhrs.push(counter);
                if (counter < 23) {
                  counter++;
                } else {
                  counter = 0;
                }
              }
              for (_i = 0, _len = skippedhrs.length; _i < _len; _i++) {
                currHr = skippedhrs[_i];
                _ref1 = _s.consumedAVG;
                for (k in _ref1) {
                  v = _ref1[k];
                  console.log("key:" + k + " val " + v);
                  for (ck in v) {
                    cv = v[ck];
                    channel = ck;
                    avgdb = cv;
                    sensor = k;
                    harr = avgdb["hourly"][currHr.toString()]["data"];
                    if (harr != null) {
                      if (harr.length > 0) {
                        htot = harr.reduce(function(t, s) {
                          return t + s;
                        });
                        havg = htot / harr.length;
                        self.emit("average", {
                          "sensor": sensor,
                          "channel": channel,
                          "type": "hourly",
                          "period": currHr,
                          "value": havg
                        });
                        avgdb["hourly"][currHr.toString()]["data"] = [];
                        darr = avgdb["daily"][_s.currDy.toString()]["data"];
                        darr.push(havg);
                      }
                    }
                  }
                }
                if (currHr === _s.cycleHr) {
                  _ref2 = _s.consumedAVG;
                  for (k in _ref2) {
                    v = _ref2[k];
                    for (ck in v) {
                      cv = v[ck];
                      channel = ck;
                      avgdb = cv;
                      sensor = k;
                      darr = avgdb["daily"][_s.currDy.toString()]["data"];
                      dtot = 0;
                      if (darr.length > 0) {
                        dtot = darr.reduce(function(t, s) {
                          return t + s;
                        });
                      }
                      self.emit("average", {
                        "sensor": sensor,
                        "channel": channel,
                        "type": "daily",
                        "period": _s.currDy,
                        "value": dtot
                      });
                      avgdb["weekly"]["0"]["data"].push(dtot);
                      avgdb["daily"][_s.currDy.toString()]["data"] = [];
                    }
                  }
                  _s.currDy += 1;
                  if (_s.currDy > 6) {
                    _s.currDy = 0;
                  }
                  if (_s.currDy === _s.cycleDy) {
                    _ref3 = _s.consumedAVG;
                    for (k in _ref3) {
                      v = _ref3[k];
                      for (ck in v) {
                        cv = v[ck];
                        channel = ck;
                        avgdb = cv;
                        sensor = k;
                        warr = avgdb["weekly"]["0"]["data"];
                        wtot = warr.reduce(function(t, s) {
                          return t + s;
                        });
                        self.emit("average", {
                          "sensor": sensor,
                          "channel": channel,
                          "type": "weekly",
                          "period": 0,
                          "value": wtot
                        });
                        avgdb["weekly"]["0"]["data"] = [];
                      }
                    }
                  }
                }
              }
            }
          }
          if (self.emitAverages) {
            _s.currHr = _s.time.getHours();
          }
        }
        _s.inMSG = false;
        _s.inREALTIME = false;
        _s.inHIST = false;
      }
      if (tagName === 'sensor') {
        _s.inSENSOR = false;
      }
      if (tagName === 'id') {
        _s.inID = false;
      }
      if (tagName === 'dsb') {
        _s.inDSB = false;
      }
      if (tagName === 'tmpr') {
        _s.inTMPR = false;
      }
      if (tagName === 'src') {
        _s.inSRC = false;
      }
      if (tagName === 'type') {
        _s.inSENSORTYPE = false;
      }
      if (tagName === 'imp') {
        _s.inIMP = false;
      }
      if (tagName === 'ipu') {
        _s.inIPU = false;
      }
      if (tagName === 'hist') {
        if (self.debug) {
          console.log(">>OUT HIST");
        }
      }
      if (tagName === 'watts') {
        return _s.inWATTS = false;
      }
    };
    this.parser.onattribute = function(attr) {};
    this.parser.onend = function() {};
    this.reader = new stream.Readable();
    this.reader._read = function(n) {};
    this.reader.pipe(this.parser);
    if (self.debug) {
      console.log("creating:", this.device);
    }
    match = /(file:)(.*)/i.exec(this.device);
    if (match != null) {
      this.serialPort = new SerialFile(match[2]);
      console.log("File Device:", match[2]);
    } else {
      this.serialPort = new SerialPort.SerialPort(this.device, {
        baudrate: 57600,
        parser: SerialPort.parsers.raw
      });
    }
    this.serialPort.on("open", function() {
      if (self.debug) {
        console.log('open');
      }
      this.on('data', function(data) {
        if (self.logfile != null) {
          fs.appendFileSync(self.logfile, data.toString());
        }
        return self.reader.push(data.toString());
      });
      this.on('end', function() {
        console.log("END communications");
        return self.emit('end');
      });
      return this.on('error', function(e) {
        return self.emit('error', e);
      });
    });
  }

  CurrentCost128XMLBaseStation.prototype.processImpulse = function() {
    var avg, avgSecs, avgdb, consumed, curDelta, curNow, data, doSpike, hrly, impPerInterval, impavg, oldRead, readinc, self, tot, _base, _name, _s;
    self = this;
    _s = self._s;
    if (_s.inREALTIME) {
      curNow = _s.time;
      self.emit("impulse", {
        time: _s.time,
        sensor: _s.sensor,
        channel: _s.channel,
        id: _s.id,
        type: _s.sensortype,
        value: _s.imp,
        ipu: _s.ipu
      });
      if (_s.impStart[_s.sensor] == null) {
        _s.impStart[_s.sensor] = _s.imp;
        _s.impStartTime[_s.sensor] = new Date(curNow);
        _s.impTime[_s.sensor] = new Date(curNow);
        _s.impLast[_s.sensor] = 0;
        if ((_base = self.reading)[_name = _s.sensor] == null) {
          _base[_name] = 0;
        }
        _s.readingBAK[_s.sensor] = self.reading[_s.sensor];
        _s.impAvg[_s.sensor] = [];
      } else {
        /*delta of impulse*/

        curDelta = _s.imp - _s.impLast[_s.sensor];
        avgSecs = (curNow - _s.impTime[_s.sensor]) / 1000;
        consumed = _s.imp - _s.impStart[_s.sensor];
        /*detect and flatten spikes*/

        doSpike = false;
        if ((self.spikeThreshold !== 0) && (curDelta > self.spikeThreshold)) {
          self.emit("impulse-spike", {
            time: _s.time,
            sensor: _s.sensor,
            channel: _s.channel,
            id: _s.id,
            type: _s.sensortype,
            spike: curDelta
          });
          if (self.debug) {
            data = "impulse-spike  " + (_s.time.toLocaleTimeString()) + " prev: " + _s.impLast[_s.sensor] + " curr: " + _s.imp + " delta: " + curDelta + ", tot-consumed: " + consumed;
          }
          console.log(data);
          if (self.debug > 1) {
            fs.appendFileSync(debugfile, data + "\r\n");
          }
          doSpike = true;
          if (_s.impAvg[_s.sensor].length >= 1) {
            tot = _s.impAvg[_s.sensor].reduce(function(t, s) {
              return t + s;
            });
            avg = tot / _s.impAvg[_s.sensor].length;
            if (self.debug > 2) {
              fs.appendFileSync(debugfile, avg + "\r\n");
            }
          }
          if (doSpike) {
            _s.impStart[_s.sensor] = _s.imp - avg;
            _s.impLast[_s.sensor] = _s.imp - avg;
            curDelta = avg;
            /*recalc consumed*/

            consumed = avg;
            oldRead = self.reading[_s.sensor];
            self.reading[_s.sensor] = _s.readingBAK[_s.sensor];
            _s.impStartTime[_s.sensor] = new Date(curNow);
            if (self.debug) {
              data = "reading reset to: " + self.reading[_s.sensor] + " from " + oldRead + " using average of: " + avg;
            }
            if (self.debug > 2) {
              fs.appendFileSync(debugfile, "Impulse correction: " + data + "\r\n");
            }
            self.emit("impulse-correction", {
              time: _s.time,
              sensor: _s.sensor,
              channel: _s.channel,
              id: _s.id,
              type: _s.sensortype,
              oldReading: oldRead,
              newReading: self.reading[_s.sensor],
              newDelta: curDelta
            });
          } else {
            _s.impStart[_s.sensor] = _s.imp;
            _s.impLast[_s.sensor] = _s.imp;
            _s.impTime[_s.sensor] = new Date(curNow);
            _s.impStartTime[_s.sensor] = new Date(curNow);
            self.reading[_s.sensor] = _s.readingBAK[_s.sensor];
            self.emit("impulse-warning", {
              time: _s.time,
              sensor: _s.sensor,
              channel: _s.channel,
              id: _s.id,
              type: _s.sensortype,
              newReading: self.reading[_s.sensor]
            });
            return;
          }
        } else {
          readinc = consumed / _s.ipu;
          _s.readingBAK[_s.sensor] = self.reading[_s.sensor] + readinc;
        }
        if (!isFinite(curDelta / _s.ipu)) {
          if (self.debug) {
            console.log("Infinity: " + curDelta + " " + _s.ipu);
          }
          console.log("State: " + (JSON.stringify(_s)));
          throw new Error("Infinity Assertion");
        }
        if (doSpike) {
          readinc = curDelta / _s.ipu;
          if (self.debug) {
            console.log("Incrementing reading by " + readinc);
          }
        }
        self.emit("impulse-reading", {
          time: _s.time,
          sensor: _s.sensor,
          channel: _s.channel,
          id: _s.id,
          type: _s.sensortype,
          reading: self.reading[_s.sensor] + readinc,
          timeFrom: _s.impStartTime[_s.sensor]
        });
        if (_s.impAvg[_s.sensor].length === 3) {
          _s.impAvg[_s.sensor].pop();
        }
        _s.impAvg[_s.sensor].push(curDelta);
        if (self.debug) {
          tot = _s.impAvg[_s.sensor].reduce(function(t, s) {
            return t + s;
          });
        }
        self.emit("impulse-delta", {
          time: _s.time,
          sensor: _s.sensor,
          channel: _s.channel,
          id: _s.id,
          type: _s.sensortype,
          delta: curDelta
        });
        impPerInterval = (curDelta / avgSecs) * 60 * 60;
        impavg = Math.floor((impPerInterval / _s.ipu) * 1000);
        self.emit("impulse-avg", {
          time: _s.time,
          sensor: _s.sensor,
          channel: _s.channel,
          id: _s.id,
          type: _s.sensortype,
          avg: impavg
        });
        if (self.emitAverages) {
          avgdb = self.getAVGDb(_s.sensor, _s.channel);
          hrly = avgdb["hourly"][_s.time.getHours().toString()]["data"];
          hrly.push(impavg);
          self.putAVGDb(_s.sensor, _s.channel, avgdb);
        }
      }
      _s.impLast[_s.sensor] = _s.imp;
      return _s.impTime[_s.sensor] = new Date(curNow);
    }
  };

  CurrentCost128XMLBaseStation.prototype.getAVGDb = function(sensor, channel) {
    var avgdb, db;
    db = this._s.consumedAVG[sensor];
    if (db == null) {
      this._s.consumedAVG[sensor] = {};
    }
    avgdb = this._s.consumedAVG[sensor][channel];
    if (avgdb == null) {
      avgdb = {
        "weekly": {
          "0": {
            "data": []
          }
        },
        "daily": {
          "0": {
            "data": []
          },
          "1": {
            "data": []
          },
          "2": {
            "data": []
          },
          "3": {
            "data": []
          },
          "4": {
            "data": []
          },
          "5": {
            "data": []
          },
          "6": {
            "data": []
          }
        },
        "hourly": {
          "0": {
            "data": []
          },
          "1": {
            "data": []
          },
          "2": {
            "data": []
          },
          "3": {
            "data": []
          },
          "4": {
            "data": []
          },
          "5": {
            "data": []
          },
          "6": {
            "data": []
          },
          "7": {
            "data": []
          },
          "8": {
            "data": []
          },
          "9": {
            "data": []
          },
          "10": {
            "data": []
          },
          "11": {
            "data": []
          },
          "12": {
            "data": []
          },
          "13": {
            "data": []
          },
          "14": {
            "data": []
          },
          "15": {
            "data": []
          },
          "16": {
            "data": []
          },
          "17": {
            "data": []
          },
          "18": {
            "data": []
          },
          "19": {
            "data": []
          },
          "20": {
            "data": []
          },
          "21": {
            "data": []
          },
          "22": {
            "data": []
          },
          "23": {
            "data": []
          }
        }
      };
      this._s.consumedAVG[sensor][channel] = avgdb;
    }
    return this._s.consumedAVG[sensor][channel];
  };

  CurrentCost128XMLBaseStation.prototype.putAVGDb = function(sensor, channel, db) {
    return this._s.consumedAVG[sensor][channel] = db;
  };

  CurrentCost128XMLBaseStation.prototype.version = function() {
    return this.ver;
  };

  CurrentCost128XMLBaseStation.prototype.close = function() {
    this.serialPort.close();
    this.parser.end();
    this.serialPort = null;
    this.reader = null;
    this.parser = null;
    this.removeAllListeners('sensor').removeAllListeners('impulse').removeAllListeners('impulse-reading').removeAllListeners('impulse-delta').removeAllListeners('impulse-avg');
    if (this.debug) {
      console.log("base --end--");
    }
  };

  return CurrentCost128XMLBaseStation;

})(EventEmitter);

module.exports.CurrentCost128XMLBaseStation = CurrentCost128XMLBaseStation;
